// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'add_car_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$AddCarEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadCarTypes,
    required TResult Function() loadCarModels,
    required TResult Function() loadConnectors,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadCarTypes,
    TResult? Function()? loadCarModels,
    TResult? Function()? loadConnectors,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadCarTypes,
    TResult Function()? loadCarModels,
    TResult Function()? loadConnectors,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadCarTypesEvent value) loadCarTypes,
    required TResult Function(_LoadCarModelsEvent value) loadCarModels,
    required TResult Function(_LoadConnectorsEvent value) loadConnectors,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadCarTypesEvent value)? loadCarTypes,
    TResult? Function(_LoadCarModelsEvent value)? loadCarModels,
    TResult? Function(_LoadConnectorsEvent value)? loadConnectors,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadCarTypesEvent value)? loadCarTypes,
    TResult Function(_LoadCarModelsEvent value)? loadCarModels,
    TResult Function(_LoadConnectorsEvent value)? loadConnectors,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddCarEventCopyWith<$Res> {
  factory $AddCarEventCopyWith(
          AddCarEvent value, $Res Function(AddCarEvent) then) =
      _$AddCarEventCopyWithImpl<$Res, AddCarEvent>;
}

/// @nodoc
class _$AddCarEventCopyWithImpl<$Res, $Val extends AddCarEvent>
    implements $AddCarEventCopyWith<$Res> {
  _$AddCarEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AddCarEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$LoadCarTypesEventImplCopyWith<$Res> {
  factory _$$LoadCarTypesEventImplCopyWith(_$LoadCarTypesEventImpl value,
          $Res Function(_$LoadCarTypesEventImpl) then) =
      __$$LoadCarTypesEventImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadCarTypesEventImplCopyWithImpl<$Res>
    extends _$AddCarEventCopyWithImpl<$Res, _$LoadCarTypesEventImpl>
    implements _$$LoadCarTypesEventImplCopyWith<$Res> {
  __$$LoadCarTypesEventImplCopyWithImpl(_$LoadCarTypesEventImpl _value,
      $Res Function(_$LoadCarTypesEventImpl) _then)
      : super(_value, _then);

  /// Create a copy of AddCarEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$LoadCarTypesEventImpl implements _LoadCarTypesEvent {
  const _$LoadCarTypesEventImpl();

  @override
  String toString() {
    return 'AddCarEvent.loadCarTypes()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadCarTypesEventImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadCarTypes,
    required TResult Function() loadCarModels,
    required TResult Function() loadConnectors,
  }) {
    return loadCarTypes();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadCarTypes,
    TResult? Function()? loadCarModels,
    TResult? Function()? loadConnectors,
  }) {
    return loadCarTypes?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadCarTypes,
    TResult Function()? loadCarModels,
    TResult Function()? loadConnectors,
    required TResult orElse(),
  }) {
    if (loadCarTypes != null) {
      return loadCarTypes();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadCarTypesEvent value) loadCarTypes,
    required TResult Function(_LoadCarModelsEvent value) loadCarModels,
    required TResult Function(_LoadConnectorsEvent value) loadConnectors,
  }) {
    return loadCarTypes(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadCarTypesEvent value)? loadCarTypes,
    TResult? Function(_LoadCarModelsEvent value)? loadCarModels,
    TResult? Function(_LoadConnectorsEvent value)? loadConnectors,
  }) {
    return loadCarTypes?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadCarTypesEvent value)? loadCarTypes,
    TResult Function(_LoadCarModelsEvent value)? loadCarModels,
    TResult Function(_LoadConnectorsEvent value)? loadConnectors,
    required TResult orElse(),
  }) {
    if (loadCarTypes != null) {
      return loadCarTypes(this);
    }
    return orElse();
  }
}

abstract class _LoadCarTypesEvent implements AddCarEvent {
  const factory _LoadCarTypesEvent() = _$LoadCarTypesEventImpl;
}

/// @nodoc
abstract class _$$LoadCarModelsEventImplCopyWith<$Res> {
  factory _$$LoadCarModelsEventImplCopyWith(_$LoadCarModelsEventImpl value,
          $Res Function(_$LoadCarModelsEventImpl) then) =
      __$$LoadCarModelsEventImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadCarModelsEventImplCopyWithImpl<$Res>
    extends _$AddCarEventCopyWithImpl<$Res, _$LoadCarModelsEventImpl>
    implements _$$LoadCarModelsEventImplCopyWith<$Res> {
  __$$LoadCarModelsEventImplCopyWithImpl(_$LoadCarModelsEventImpl _value,
      $Res Function(_$LoadCarModelsEventImpl) _then)
      : super(_value, _then);

  /// Create a copy of AddCarEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$LoadCarModelsEventImpl implements _LoadCarModelsEvent {
  const _$LoadCarModelsEventImpl();

  @override
  String toString() {
    return 'AddCarEvent.loadCarModels()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadCarModelsEventImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadCarTypes,
    required TResult Function() loadCarModels,
    required TResult Function() loadConnectors,
  }) {
    return loadCarModels();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadCarTypes,
    TResult? Function()? loadCarModels,
    TResult? Function()? loadConnectors,
  }) {
    return loadCarModels?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadCarTypes,
    TResult Function()? loadCarModels,
    TResult Function()? loadConnectors,
    required TResult orElse(),
  }) {
    if (loadCarModels != null) {
      return loadCarModels();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadCarTypesEvent value) loadCarTypes,
    required TResult Function(_LoadCarModelsEvent value) loadCarModels,
    required TResult Function(_LoadConnectorsEvent value) loadConnectors,
  }) {
    return loadCarModels(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadCarTypesEvent value)? loadCarTypes,
    TResult? Function(_LoadCarModelsEvent value)? loadCarModels,
    TResult? Function(_LoadConnectorsEvent value)? loadConnectors,
  }) {
    return loadCarModels?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadCarTypesEvent value)? loadCarTypes,
    TResult Function(_LoadCarModelsEvent value)? loadCarModels,
    TResult Function(_LoadConnectorsEvent value)? loadConnectors,
    required TResult orElse(),
  }) {
    if (loadCarModels != null) {
      return loadCarModels(this);
    }
    return orElse();
  }
}

abstract class _LoadCarModelsEvent implements AddCarEvent {
  const factory _LoadCarModelsEvent() = _$LoadCarModelsEventImpl;
}

/// @nodoc
abstract class _$$LoadConnectorsEventImplCopyWith<$Res> {
  factory _$$LoadConnectorsEventImplCopyWith(_$LoadConnectorsEventImpl value,
          $Res Function(_$LoadConnectorsEventImpl) then) =
      __$$LoadConnectorsEventImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadConnectorsEventImplCopyWithImpl<$Res>
    extends _$AddCarEventCopyWithImpl<$Res, _$LoadConnectorsEventImpl>
    implements _$$LoadConnectorsEventImplCopyWith<$Res> {
  __$$LoadConnectorsEventImplCopyWithImpl(_$LoadConnectorsEventImpl _value,
      $Res Function(_$LoadConnectorsEventImpl) _then)
      : super(_value, _then);

  /// Create a copy of AddCarEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$LoadConnectorsEventImpl implements _LoadConnectorsEvent {
  const _$LoadConnectorsEventImpl();

  @override
  String toString() {
    return 'AddCarEvent.loadConnectors()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadConnectorsEventImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadCarTypes,
    required TResult Function() loadCarModels,
    required TResult Function() loadConnectors,
  }) {
    return loadConnectors();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadCarTypes,
    TResult? Function()? loadCarModels,
    TResult? Function()? loadConnectors,
  }) {
    return loadConnectors?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadCarTypes,
    TResult Function()? loadCarModels,
    TResult Function()? loadConnectors,
    required TResult orElse(),
  }) {
    if (loadConnectors != null) {
      return loadConnectors();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadCarTypesEvent value) loadCarTypes,
    required TResult Function(_LoadCarModelsEvent value) loadCarModels,
    required TResult Function(_LoadConnectorsEvent value) loadConnectors,
  }) {
    return loadConnectors(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadCarTypesEvent value)? loadCarTypes,
    TResult? Function(_LoadCarModelsEvent value)? loadCarModels,
    TResult? Function(_LoadConnectorsEvent value)? loadConnectors,
  }) {
    return loadConnectors?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadCarTypesEvent value)? loadCarTypes,
    TResult Function(_LoadCarModelsEvent value)? loadCarModels,
    TResult Function(_LoadConnectorsEvent value)? loadConnectors,
    required TResult orElse(),
  }) {
    if (loadConnectors != null) {
      return loadConnectors(this);
    }
    return orElse();
  }
}

abstract class _LoadConnectorsEvent implements AddCarEvent {
  const factory _LoadConnectorsEvent() = _$LoadConnectorsEventImpl;
}

/// @nodoc
mixin _$AddCarState {
  List<CarTypeModel> get carTypes => throw _privateConstructorUsedError;
  List<CarModel> get carModels => throw _privateConstructorUsedError;
  List<ConnectorTypeModel> get connectors => throw _privateConstructorUsedError;

  /// Create a copy of AddCarState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AddCarStateCopyWith<AddCarState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddCarStateCopyWith<$Res> {
  factory $AddCarStateCopyWith(
          AddCarState value, $Res Function(AddCarState) then) =
      _$AddCarStateCopyWithImpl<$Res, AddCarState>;
  @useResult
  $Res call(
      {List<CarTypeModel> carTypes,
      List<CarModel> carModels,
      List<ConnectorTypeModel> connectors});
}

/// @nodoc
class _$AddCarStateCopyWithImpl<$Res, $Val extends AddCarState>
    implements $AddCarStateCopyWith<$Res> {
  _$AddCarStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AddCarState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? carTypes = null,
    Object? carModels = null,
    Object? connectors = null,
  }) {
    return _then(_value.copyWith(
      carTypes: null == carTypes
          ? _value.carTypes
          : carTypes // ignore: cast_nullable_to_non_nullable
              as List<CarTypeModel>,
      carModels: null == carModels
          ? _value.carModels
          : carModels // ignore: cast_nullable_to_non_nullable
              as List<CarModel>,
      connectors: null == connectors
          ? _value.connectors
          : connectors // ignore: cast_nullable_to_non_nullable
              as List<ConnectorTypeModel>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AddCarStateImplCopyWith<$Res>
    implements $AddCarStateCopyWith<$Res> {
  factory _$$AddCarStateImplCopyWith(
          _$AddCarStateImpl value, $Res Function(_$AddCarStateImpl) then) =
      __$$AddCarStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<CarTypeModel> carTypes,
      List<CarModel> carModels,
      List<ConnectorTypeModel> connectors});
}

/// @nodoc
class __$$AddCarStateImplCopyWithImpl<$Res>
    extends _$AddCarStateCopyWithImpl<$Res, _$AddCarStateImpl>
    implements _$$AddCarStateImplCopyWith<$Res> {
  __$$AddCarStateImplCopyWithImpl(
      _$AddCarStateImpl _value, $Res Function(_$AddCarStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of AddCarState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? carTypes = null,
    Object? carModels = null,
    Object? connectors = null,
  }) {
    return _then(_$AddCarStateImpl(
      carTypes: null == carTypes
          ? _value._carTypes
          : carTypes // ignore: cast_nullable_to_non_nullable
              as List<CarTypeModel>,
      carModels: null == carModels
          ? _value._carModels
          : carModels // ignore: cast_nullable_to_non_nullable
              as List<CarModel>,
      connectors: null == connectors
          ? _value._connectors
          : connectors // ignore: cast_nullable_to_non_nullable
              as List<ConnectorTypeModel>,
    ));
  }
}

/// @nodoc

class _$AddCarStateImpl implements _AddCarState {
  const _$AddCarStateImpl(
      {final List<CarTypeModel> carTypes = const [],
      final List<CarModel> carModels = const [],
      final List<ConnectorTypeModel> connectors = const []})
      : _carTypes = carTypes,
        _carModels = carModels,
        _connectors = connectors;

  final List<CarTypeModel> _carTypes;
  @override
  @JsonKey()
  List<CarTypeModel> get carTypes {
    if (_carTypes is EqualUnmodifiableListView) return _carTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_carTypes);
  }

  final List<CarModel> _carModels;
  @override
  @JsonKey()
  List<CarModel> get carModels {
    if (_carModels is EqualUnmodifiableListView) return _carModels;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_carModels);
  }

  final List<ConnectorTypeModel> _connectors;
  @override
  @JsonKey()
  List<ConnectorTypeModel> get connectors {
    if (_connectors is EqualUnmodifiableListView) return _connectors;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_connectors);
  }

  @override
  String toString() {
    return 'AddCarState(carTypes: $carTypes, carModels: $carModels, connectors: $connectors)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddCarStateImpl &&
            const DeepCollectionEquality().equals(other._carTypes, _carTypes) &&
            const DeepCollectionEquality()
                .equals(other._carModels, _carModels) &&
            const DeepCollectionEquality()
                .equals(other._connectors, _connectors));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_carTypes),
      const DeepCollectionEquality().hash(_carModels),
      const DeepCollectionEquality().hash(_connectors));

  /// Create a copy of AddCarState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AddCarStateImplCopyWith<_$AddCarStateImpl> get copyWith =>
      __$$AddCarStateImplCopyWithImpl<_$AddCarStateImpl>(this, _$identity);
}

abstract class _AddCarState implements AddCarState {
  const factory _AddCarState(
      {final List<CarTypeModel> carTypes,
      final List<CarModel> carModels,
      final List<ConnectorTypeModel> connectors}) = _$AddCarStateImpl;

  @override
  List<CarTypeModel> get carTypes;
  @override
  List<CarModel> get carModels;
  @override
  List<ConnectorTypeModel> get connectors;

  /// Create a copy of AddCarState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AddCarStateImplCopyWith<_$AddCarStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
