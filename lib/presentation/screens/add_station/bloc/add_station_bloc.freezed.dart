// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'add_station_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$AddStationEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(List<File> images) imagesSelected,
    required TResult Function(int index) removeImage,
    required TResult Function(ConnectorTypeModel? selectedConnector)
        connectorTypeChangedEvent,
    required TResult Function(String startTime) startTimeSelected,
    required TResult Function(String endTime) endTimeSelected,
    required TResult Function(String address) getAddress,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(List<File> images)? imagesSelected,
    TResult? Function(int index)? removeImage,
    TResult? Function(ConnectorTypeModel? selectedConnector)?
        connectorTypeChangedEvent,
    TResult? Function(String startTime)? startTimeSelected,
    TResult? Function(String endTime)? endTimeSelected,
    TResult? Function(String address)? getAddress,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(List<File> images)? imagesSelected,
    TResult Function(int index)? removeImage,
    TResult Function(ConnectorTypeModel? selectedConnector)?
        connectorTypeChangedEvent,
    TResult Function(String startTime)? startTimeSelected,
    TResult Function(String endTime)? endTimeSelected,
    TResult Function(String address)? getAddress,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_StartedEvent value) started,
    required TResult Function(_ImagesSelectedEvent value) imagesSelected,
    required TResult Function(_RemoveImageEvent value) removeImage,
    required TResult Function(_ConnectorTypeChangedEvent value)
        connectorTypeChangedEvent,
    required TResult Function(_StartTimeSelectedEvent value) startTimeSelected,
    required TResult Function(_EndTimeSelectedEvent value) endTimeSelected,
    required TResult Function(_GetAddressEvent value) getAddress,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_StartedEvent value)? started,
    TResult? Function(_ImagesSelectedEvent value)? imagesSelected,
    TResult? Function(_RemoveImageEvent value)? removeImage,
    TResult? Function(_ConnectorTypeChangedEvent value)?
        connectorTypeChangedEvent,
    TResult? Function(_StartTimeSelectedEvent value)? startTimeSelected,
    TResult? Function(_EndTimeSelectedEvent value)? endTimeSelected,
    TResult? Function(_GetAddressEvent value)? getAddress,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_StartedEvent value)? started,
    TResult Function(_ImagesSelectedEvent value)? imagesSelected,
    TResult Function(_RemoveImageEvent value)? removeImage,
    TResult Function(_ConnectorTypeChangedEvent value)?
        connectorTypeChangedEvent,
    TResult Function(_StartTimeSelectedEvent value)? startTimeSelected,
    TResult Function(_EndTimeSelectedEvent value)? endTimeSelected,
    TResult Function(_GetAddressEvent value)? getAddress,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddStationEventCopyWith<$Res> {
  factory $AddStationEventCopyWith(
          AddStationEvent value, $Res Function(AddStationEvent) then) =
      _$AddStationEventCopyWithImpl<$Res, AddStationEvent>;
}

/// @nodoc
class _$AddStationEventCopyWithImpl<$Res, $Val extends AddStationEvent>
    implements $AddStationEventCopyWith<$Res> {
  _$AddStationEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AddStationEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$StartedEventImplCopyWith<$Res> {
  factory _$$StartedEventImplCopyWith(
          _$StartedEventImpl value, $Res Function(_$StartedEventImpl) then) =
      __$$StartedEventImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$StartedEventImplCopyWithImpl<$Res>
    extends _$AddStationEventCopyWithImpl<$Res, _$StartedEventImpl>
    implements _$$StartedEventImplCopyWith<$Res> {
  __$$StartedEventImplCopyWithImpl(
      _$StartedEventImpl _value, $Res Function(_$StartedEventImpl) _then)
      : super(_value, _then);

  /// Create a copy of AddStationEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$StartedEventImpl implements _StartedEvent {
  const _$StartedEventImpl();

  @override
  String toString() {
    return 'AddStationEvent.started()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$StartedEventImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(List<File> images) imagesSelected,
    required TResult Function(int index) removeImage,
    required TResult Function(ConnectorTypeModel? selectedConnector)
        connectorTypeChangedEvent,
    required TResult Function(String startTime) startTimeSelected,
    required TResult Function(String endTime) endTimeSelected,
    required TResult Function(String address) getAddress,
  }) {
    return started();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(List<File> images)? imagesSelected,
    TResult? Function(int index)? removeImage,
    TResult? Function(ConnectorTypeModel? selectedConnector)?
        connectorTypeChangedEvent,
    TResult? Function(String startTime)? startTimeSelected,
    TResult? Function(String endTime)? endTimeSelected,
    TResult? Function(String address)? getAddress,
  }) {
    return started?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(List<File> images)? imagesSelected,
    TResult Function(int index)? removeImage,
    TResult Function(ConnectorTypeModel? selectedConnector)?
        connectorTypeChangedEvent,
    TResult Function(String startTime)? startTimeSelected,
    TResult Function(String endTime)? endTimeSelected,
    TResult Function(String address)? getAddress,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_StartedEvent value) started,
    required TResult Function(_ImagesSelectedEvent value) imagesSelected,
    required TResult Function(_RemoveImageEvent value) removeImage,
    required TResult Function(_ConnectorTypeChangedEvent value)
        connectorTypeChangedEvent,
    required TResult Function(_StartTimeSelectedEvent value) startTimeSelected,
    required TResult Function(_EndTimeSelectedEvent value) endTimeSelected,
    required TResult Function(_GetAddressEvent value) getAddress,
  }) {
    return started(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_StartedEvent value)? started,
    TResult? Function(_ImagesSelectedEvent value)? imagesSelected,
    TResult? Function(_RemoveImageEvent value)? removeImage,
    TResult? Function(_ConnectorTypeChangedEvent value)?
        connectorTypeChangedEvent,
    TResult? Function(_StartTimeSelectedEvent value)? startTimeSelected,
    TResult? Function(_EndTimeSelectedEvent value)? endTimeSelected,
    TResult? Function(_GetAddressEvent value)? getAddress,
  }) {
    return started?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_StartedEvent value)? started,
    TResult Function(_ImagesSelectedEvent value)? imagesSelected,
    TResult Function(_RemoveImageEvent value)? removeImage,
    TResult Function(_ConnectorTypeChangedEvent value)?
        connectorTypeChangedEvent,
    TResult Function(_StartTimeSelectedEvent value)? startTimeSelected,
    TResult Function(_EndTimeSelectedEvent value)? endTimeSelected,
    TResult Function(_GetAddressEvent value)? getAddress,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started(this);
    }
    return orElse();
  }
}

abstract class _StartedEvent implements AddStationEvent {
  const factory _StartedEvent() = _$StartedEventImpl;
}

/// @nodoc
abstract class _$$ImagesSelectedEventImplCopyWith<$Res> {
  factory _$$ImagesSelectedEventImplCopyWith(_$ImagesSelectedEventImpl value,
          $Res Function(_$ImagesSelectedEventImpl) then) =
      __$$ImagesSelectedEventImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<File> images});
}

/// @nodoc
class __$$ImagesSelectedEventImplCopyWithImpl<$Res>
    extends _$AddStationEventCopyWithImpl<$Res, _$ImagesSelectedEventImpl>
    implements _$$ImagesSelectedEventImplCopyWith<$Res> {
  __$$ImagesSelectedEventImplCopyWithImpl(_$ImagesSelectedEventImpl _value,
      $Res Function(_$ImagesSelectedEventImpl) _then)
      : super(_value, _then);

  /// Create a copy of AddStationEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? images = null,
  }) {
    return _then(_$ImagesSelectedEventImpl(
      null == images
          ? _value._images
          : images // ignore: cast_nullable_to_non_nullable
              as List<File>,
    ));
  }
}

/// @nodoc

class _$ImagesSelectedEventImpl implements _ImagesSelectedEvent {
  const _$ImagesSelectedEventImpl(final List<File> images) : _images = images;

  final List<File> _images;
  @override
  List<File> get images {
    if (_images is EqualUnmodifiableListView) return _images;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_images);
  }

  @override
  String toString() {
    return 'AddStationEvent.imagesSelected(images: $images)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ImagesSelectedEventImpl &&
            const DeepCollectionEquality().equals(other._images, _images));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_images));

  /// Create a copy of AddStationEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ImagesSelectedEventImplCopyWith<_$ImagesSelectedEventImpl> get copyWith =>
      __$$ImagesSelectedEventImplCopyWithImpl<_$ImagesSelectedEventImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(List<File> images) imagesSelected,
    required TResult Function(int index) removeImage,
    required TResult Function(ConnectorTypeModel? selectedConnector)
        connectorTypeChangedEvent,
    required TResult Function(String startTime) startTimeSelected,
    required TResult Function(String endTime) endTimeSelected,
    required TResult Function(String address) getAddress,
  }) {
    return imagesSelected(images);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(List<File> images)? imagesSelected,
    TResult? Function(int index)? removeImage,
    TResult? Function(ConnectorTypeModel? selectedConnector)?
        connectorTypeChangedEvent,
    TResult? Function(String startTime)? startTimeSelected,
    TResult? Function(String endTime)? endTimeSelected,
    TResult? Function(String address)? getAddress,
  }) {
    return imagesSelected?.call(images);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(List<File> images)? imagesSelected,
    TResult Function(int index)? removeImage,
    TResult Function(ConnectorTypeModel? selectedConnector)?
        connectorTypeChangedEvent,
    TResult Function(String startTime)? startTimeSelected,
    TResult Function(String endTime)? endTimeSelected,
    TResult Function(String address)? getAddress,
    required TResult orElse(),
  }) {
    if (imagesSelected != null) {
      return imagesSelected(images);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_StartedEvent value) started,
    required TResult Function(_ImagesSelectedEvent value) imagesSelected,
    required TResult Function(_RemoveImageEvent value) removeImage,
    required TResult Function(_ConnectorTypeChangedEvent value)
        connectorTypeChangedEvent,
    required TResult Function(_StartTimeSelectedEvent value) startTimeSelected,
    required TResult Function(_EndTimeSelectedEvent value) endTimeSelected,
    required TResult Function(_GetAddressEvent value) getAddress,
  }) {
    return imagesSelected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_StartedEvent value)? started,
    TResult? Function(_ImagesSelectedEvent value)? imagesSelected,
    TResult? Function(_RemoveImageEvent value)? removeImage,
    TResult? Function(_ConnectorTypeChangedEvent value)?
        connectorTypeChangedEvent,
    TResult? Function(_StartTimeSelectedEvent value)? startTimeSelected,
    TResult? Function(_EndTimeSelectedEvent value)? endTimeSelected,
    TResult? Function(_GetAddressEvent value)? getAddress,
  }) {
    return imagesSelected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_StartedEvent value)? started,
    TResult Function(_ImagesSelectedEvent value)? imagesSelected,
    TResult Function(_RemoveImageEvent value)? removeImage,
    TResult Function(_ConnectorTypeChangedEvent value)?
        connectorTypeChangedEvent,
    TResult Function(_StartTimeSelectedEvent value)? startTimeSelected,
    TResult Function(_EndTimeSelectedEvent value)? endTimeSelected,
    TResult Function(_GetAddressEvent value)? getAddress,
    required TResult orElse(),
  }) {
    if (imagesSelected != null) {
      return imagesSelected(this);
    }
    return orElse();
  }
}

abstract class _ImagesSelectedEvent implements AddStationEvent {
  const factory _ImagesSelectedEvent(final List<File> images) =
      _$ImagesSelectedEventImpl;

  List<File> get images;

  /// Create a copy of AddStationEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ImagesSelectedEventImplCopyWith<_$ImagesSelectedEventImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RemoveImageEventImplCopyWith<$Res> {
  factory _$$RemoveImageEventImplCopyWith(_$RemoveImageEventImpl value,
          $Res Function(_$RemoveImageEventImpl) then) =
      __$$RemoveImageEventImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int index});
}

/// @nodoc
class __$$RemoveImageEventImplCopyWithImpl<$Res>
    extends _$AddStationEventCopyWithImpl<$Res, _$RemoveImageEventImpl>
    implements _$$RemoveImageEventImplCopyWith<$Res> {
  __$$RemoveImageEventImplCopyWithImpl(_$RemoveImageEventImpl _value,
      $Res Function(_$RemoveImageEventImpl) _then)
      : super(_value, _then);

  /// Create a copy of AddStationEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
  }) {
    return _then(_$RemoveImageEventImpl(
      null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$RemoveImageEventImpl implements _RemoveImageEvent {
  const _$RemoveImageEventImpl(this.index);

  @override
  final int index;

  @override
  String toString() {
    return 'AddStationEvent.removeImage(index: $index)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RemoveImageEventImpl &&
            (identical(other.index, index) || other.index == index));
  }

  @override
  int get hashCode => Object.hash(runtimeType, index);

  /// Create a copy of AddStationEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$RemoveImageEventImplCopyWith<_$RemoveImageEventImpl> get copyWith =>
      __$$RemoveImageEventImplCopyWithImpl<_$RemoveImageEventImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(List<File> images) imagesSelected,
    required TResult Function(int index) removeImage,
    required TResult Function(ConnectorTypeModel? selectedConnector)
        connectorTypeChangedEvent,
    required TResult Function(String startTime) startTimeSelected,
    required TResult Function(String endTime) endTimeSelected,
    required TResult Function(String address) getAddress,
  }) {
    return removeImage(index);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(List<File> images)? imagesSelected,
    TResult? Function(int index)? removeImage,
    TResult? Function(ConnectorTypeModel? selectedConnector)?
        connectorTypeChangedEvent,
    TResult? Function(String startTime)? startTimeSelected,
    TResult? Function(String endTime)? endTimeSelected,
    TResult? Function(String address)? getAddress,
  }) {
    return removeImage?.call(index);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(List<File> images)? imagesSelected,
    TResult Function(int index)? removeImage,
    TResult Function(ConnectorTypeModel? selectedConnector)?
        connectorTypeChangedEvent,
    TResult Function(String startTime)? startTimeSelected,
    TResult Function(String endTime)? endTimeSelected,
    TResult Function(String address)? getAddress,
    required TResult orElse(),
  }) {
    if (removeImage != null) {
      return removeImage(index);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_StartedEvent value) started,
    required TResult Function(_ImagesSelectedEvent value) imagesSelected,
    required TResult Function(_RemoveImageEvent value) removeImage,
    required TResult Function(_ConnectorTypeChangedEvent value)
        connectorTypeChangedEvent,
    required TResult Function(_StartTimeSelectedEvent value) startTimeSelected,
    required TResult Function(_EndTimeSelectedEvent value) endTimeSelected,
    required TResult Function(_GetAddressEvent value) getAddress,
  }) {
    return removeImage(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_StartedEvent value)? started,
    TResult? Function(_ImagesSelectedEvent value)? imagesSelected,
    TResult? Function(_RemoveImageEvent value)? removeImage,
    TResult? Function(_ConnectorTypeChangedEvent value)?
        connectorTypeChangedEvent,
    TResult? Function(_StartTimeSelectedEvent value)? startTimeSelected,
    TResult? Function(_EndTimeSelectedEvent value)? endTimeSelected,
    TResult? Function(_GetAddressEvent value)? getAddress,
  }) {
    return removeImage?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_StartedEvent value)? started,
    TResult Function(_ImagesSelectedEvent value)? imagesSelected,
    TResult Function(_RemoveImageEvent value)? removeImage,
    TResult Function(_ConnectorTypeChangedEvent value)?
        connectorTypeChangedEvent,
    TResult Function(_StartTimeSelectedEvent value)? startTimeSelected,
    TResult Function(_EndTimeSelectedEvent value)? endTimeSelected,
    TResult Function(_GetAddressEvent value)? getAddress,
    required TResult orElse(),
  }) {
    if (removeImage != null) {
      return removeImage(this);
    }
    return orElse();
  }
}

abstract class _RemoveImageEvent implements AddStationEvent {
  const factory _RemoveImageEvent(final int index) = _$RemoveImageEventImpl;

  int get index;

  /// Create a copy of AddStationEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$RemoveImageEventImplCopyWith<_$RemoveImageEventImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ConnectorTypeChangedEventImplCopyWith<$Res> {
  factory _$$ConnectorTypeChangedEventImplCopyWith(
          _$ConnectorTypeChangedEventImpl value,
          $Res Function(_$ConnectorTypeChangedEventImpl) then) =
      __$$ConnectorTypeChangedEventImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ConnectorTypeModel? selectedConnector});
}

/// @nodoc
class __$$ConnectorTypeChangedEventImplCopyWithImpl<$Res>
    extends _$AddStationEventCopyWithImpl<$Res, _$ConnectorTypeChangedEventImpl>
    implements _$$ConnectorTypeChangedEventImplCopyWith<$Res> {
  __$$ConnectorTypeChangedEventImplCopyWithImpl(
      _$ConnectorTypeChangedEventImpl _value,
      $Res Function(_$ConnectorTypeChangedEventImpl) _then)
      : super(_value, _then);

  /// Create a copy of AddStationEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? selectedConnector = freezed,
  }) {
    return _then(_$ConnectorTypeChangedEventImpl(
      freezed == selectedConnector
          ? _value.selectedConnector
          : selectedConnector // ignore: cast_nullable_to_non_nullable
              as ConnectorTypeModel?,
    ));
  }
}

/// @nodoc

class _$ConnectorTypeChangedEventImpl implements _ConnectorTypeChangedEvent {
  const _$ConnectorTypeChangedEventImpl(this.selectedConnector);

  @override
  final ConnectorTypeModel? selectedConnector;

  @override
  String toString() {
    return 'AddStationEvent.connectorTypeChangedEvent(selectedConnector: $selectedConnector)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ConnectorTypeChangedEventImpl &&
            const DeepCollectionEquality()
                .equals(other.selectedConnector, selectedConnector));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(selectedConnector));

  /// Create a copy of AddStationEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ConnectorTypeChangedEventImplCopyWith<_$ConnectorTypeChangedEventImpl>
      get copyWith => __$$ConnectorTypeChangedEventImplCopyWithImpl<
          _$ConnectorTypeChangedEventImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(List<File> images) imagesSelected,
    required TResult Function(int index) removeImage,
    required TResult Function(ConnectorTypeModel? selectedConnector)
        connectorTypeChangedEvent,
    required TResult Function(String startTime) startTimeSelected,
    required TResult Function(String endTime) endTimeSelected,
    required TResult Function(String address) getAddress,
  }) {
    return connectorTypeChangedEvent(selectedConnector);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(List<File> images)? imagesSelected,
    TResult? Function(int index)? removeImage,
    TResult? Function(ConnectorTypeModel? selectedConnector)?
        connectorTypeChangedEvent,
    TResult? Function(String startTime)? startTimeSelected,
    TResult? Function(String endTime)? endTimeSelected,
    TResult? Function(String address)? getAddress,
  }) {
    return connectorTypeChangedEvent?.call(selectedConnector);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(List<File> images)? imagesSelected,
    TResult Function(int index)? removeImage,
    TResult Function(ConnectorTypeModel? selectedConnector)?
        connectorTypeChangedEvent,
    TResult Function(String startTime)? startTimeSelected,
    TResult Function(String endTime)? endTimeSelected,
    TResult Function(String address)? getAddress,
    required TResult orElse(),
  }) {
    if (connectorTypeChangedEvent != null) {
      return connectorTypeChangedEvent(selectedConnector);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_StartedEvent value) started,
    required TResult Function(_ImagesSelectedEvent value) imagesSelected,
    required TResult Function(_RemoveImageEvent value) removeImage,
    required TResult Function(_ConnectorTypeChangedEvent value)
        connectorTypeChangedEvent,
    required TResult Function(_StartTimeSelectedEvent value) startTimeSelected,
    required TResult Function(_EndTimeSelectedEvent value) endTimeSelected,
    required TResult Function(_GetAddressEvent value) getAddress,
  }) {
    return connectorTypeChangedEvent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_StartedEvent value)? started,
    TResult? Function(_ImagesSelectedEvent value)? imagesSelected,
    TResult? Function(_RemoveImageEvent value)? removeImage,
    TResult? Function(_ConnectorTypeChangedEvent value)?
        connectorTypeChangedEvent,
    TResult? Function(_StartTimeSelectedEvent value)? startTimeSelected,
    TResult? Function(_EndTimeSelectedEvent value)? endTimeSelected,
    TResult? Function(_GetAddressEvent value)? getAddress,
  }) {
    return connectorTypeChangedEvent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_StartedEvent value)? started,
    TResult Function(_ImagesSelectedEvent value)? imagesSelected,
    TResult Function(_RemoveImageEvent value)? removeImage,
    TResult Function(_ConnectorTypeChangedEvent value)?
        connectorTypeChangedEvent,
    TResult Function(_StartTimeSelectedEvent value)? startTimeSelected,
    TResult Function(_EndTimeSelectedEvent value)? endTimeSelected,
    TResult Function(_GetAddressEvent value)? getAddress,
    required TResult orElse(),
  }) {
    if (connectorTypeChangedEvent != null) {
      return connectorTypeChangedEvent(this);
    }
    return orElse();
  }
}

abstract class _ConnectorTypeChangedEvent implements AddStationEvent {
  const factory _ConnectorTypeChangedEvent(
          final ConnectorTypeModel? selectedConnector) =
      _$ConnectorTypeChangedEventImpl;

  ConnectorTypeModel? get selectedConnector;

  /// Create a copy of AddStationEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ConnectorTypeChangedEventImplCopyWith<_$ConnectorTypeChangedEventImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$StartTimeSelectedEventImplCopyWith<$Res> {
  factory _$$StartTimeSelectedEventImplCopyWith(
          _$StartTimeSelectedEventImpl value,
          $Res Function(_$StartTimeSelectedEventImpl) then) =
      __$$StartTimeSelectedEventImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String startTime});
}

/// @nodoc
class __$$StartTimeSelectedEventImplCopyWithImpl<$Res>
    extends _$AddStationEventCopyWithImpl<$Res, _$StartTimeSelectedEventImpl>
    implements _$$StartTimeSelectedEventImplCopyWith<$Res> {
  __$$StartTimeSelectedEventImplCopyWithImpl(
      _$StartTimeSelectedEventImpl _value,
      $Res Function(_$StartTimeSelectedEventImpl) _then)
      : super(_value, _then);

  /// Create a copy of AddStationEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? startTime = null,
  }) {
    return _then(_$StartTimeSelectedEventImpl(
      null == startTime
          ? _value.startTime
          : startTime // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$StartTimeSelectedEventImpl implements _StartTimeSelectedEvent {
  const _$StartTimeSelectedEventImpl(this.startTime);

  @override
  final String startTime;

  @override
  String toString() {
    return 'AddStationEvent.startTimeSelected(startTime: $startTime)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StartTimeSelectedEventImpl &&
            (identical(other.startTime, startTime) ||
                other.startTime == startTime));
  }

  @override
  int get hashCode => Object.hash(runtimeType, startTime);

  /// Create a copy of AddStationEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$StartTimeSelectedEventImplCopyWith<_$StartTimeSelectedEventImpl>
      get copyWith => __$$StartTimeSelectedEventImplCopyWithImpl<
          _$StartTimeSelectedEventImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(List<File> images) imagesSelected,
    required TResult Function(int index) removeImage,
    required TResult Function(ConnectorTypeModel? selectedConnector)
        connectorTypeChangedEvent,
    required TResult Function(String startTime) startTimeSelected,
    required TResult Function(String endTime) endTimeSelected,
    required TResult Function(String address) getAddress,
  }) {
    return startTimeSelected(startTime);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(List<File> images)? imagesSelected,
    TResult? Function(int index)? removeImage,
    TResult? Function(ConnectorTypeModel? selectedConnector)?
        connectorTypeChangedEvent,
    TResult? Function(String startTime)? startTimeSelected,
    TResult? Function(String endTime)? endTimeSelected,
    TResult? Function(String address)? getAddress,
  }) {
    return startTimeSelected?.call(startTime);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(List<File> images)? imagesSelected,
    TResult Function(int index)? removeImage,
    TResult Function(ConnectorTypeModel? selectedConnector)?
        connectorTypeChangedEvent,
    TResult Function(String startTime)? startTimeSelected,
    TResult Function(String endTime)? endTimeSelected,
    TResult Function(String address)? getAddress,
    required TResult orElse(),
  }) {
    if (startTimeSelected != null) {
      return startTimeSelected(startTime);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_StartedEvent value) started,
    required TResult Function(_ImagesSelectedEvent value) imagesSelected,
    required TResult Function(_RemoveImageEvent value) removeImage,
    required TResult Function(_ConnectorTypeChangedEvent value)
        connectorTypeChangedEvent,
    required TResult Function(_StartTimeSelectedEvent value) startTimeSelected,
    required TResult Function(_EndTimeSelectedEvent value) endTimeSelected,
    required TResult Function(_GetAddressEvent value) getAddress,
  }) {
    return startTimeSelected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_StartedEvent value)? started,
    TResult? Function(_ImagesSelectedEvent value)? imagesSelected,
    TResult? Function(_RemoveImageEvent value)? removeImage,
    TResult? Function(_ConnectorTypeChangedEvent value)?
        connectorTypeChangedEvent,
    TResult? Function(_StartTimeSelectedEvent value)? startTimeSelected,
    TResult? Function(_EndTimeSelectedEvent value)? endTimeSelected,
    TResult? Function(_GetAddressEvent value)? getAddress,
  }) {
    return startTimeSelected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_StartedEvent value)? started,
    TResult Function(_ImagesSelectedEvent value)? imagesSelected,
    TResult Function(_RemoveImageEvent value)? removeImage,
    TResult Function(_ConnectorTypeChangedEvent value)?
        connectorTypeChangedEvent,
    TResult Function(_StartTimeSelectedEvent value)? startTimeSelected,
    TResult Function(_EndTimeSelectedEvent value)? endTimeSelected,
    TResult Function(_GetAddressEvent value)? getAddress,
    required TResult orElse(),
  }) {
    if (startTimeSelected != null) {
      return startTimeSelected(this);
    }
    return orElse();
  }
}

abstract class _StartTimeSelectedEvent implements AddStationEvent {
  const factory _StartTimeSelectedEvent(final String startTime) =
      _$StartTimeSelectedEventImpl;

  String get startTime;

  /// Create a copy of AddStationEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$StartTimeSelectedEventImplCopyWith<_$StartTimeSelectedEventImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EndTimeSelectedEventImplCopyWith<$Res> {
  factory _$$EndTimeSelectedEventImplCopyWith(_$EndTimeSelectedEventImpl value,
          $Res Function(_$EndTimeSelectedEventImpl) then) =
      __$$EndTimeSelectedEventImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String endTime});
}

/// @nodoc
class __$$EndTimeSelectedEventImplCopyWithImpl<$Res>
    extends _$AddStationEventCopyWithImpl<$Res, _$EndTimeSelectedEventImpl>
    implements _$$EndTimeSelectedEventImplCopyWith<$Res> {
  __$$EndTimeSelectedEventImplCopyWithImpl(_$EndTimeSelectedEventImpl _value,
      $Res Function(_$EndTimeSelectedEventImpl) _then)
      : super(_value, _then);

  /// Create a copy of AddStationEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? endTime = null,
  }) {
    return _then(_$EndTimeSelectedEventImpl(
      null == endTime
          ? _value.endTime
          : endTime // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$EndTimeSelectedEventImpl implements _EndTimeSelectedEvent {
  const _$EndTimeSelectedEventImpl(this.endTime);

  @override
  final String endTime;

  @override
  String toString() {
    return 'AddStationEvent.endTimeSelected(endTime: $endTime)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EndTimeSelectedEventImpl &&
            (identical(other.endTime, endTime) || other.endTime == endTime));
  }

  @override
  int get hashCode => Object.hash(runtimeType, endTime);

  /// Create a copy of AddStationEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$EndTimeSelectedEventImplCopyWith<_$EndTimeSelectedEventImpl>
      get copyWith =>
          __$$EndTimeSelectedEventImplCopyWithImpl<_$EndTimeSelectedEventImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(List<File> images) imagesSelected,
    required TResult Function(int index) removeImage,
    required TResult Function(ConnectorTypeModel? selectedConnector)
        connectorTypeChangedEvent,
    required TResult Function(String startTime) startTimeSelected,
    required TResult Function(String endTime) endTimeSelected,
    required TResult Function(String address) getAddress,
  }) {
    return endTimeSelected(endTime);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(List<File> images)? imagesSelected,
    TResult? Function(int index)? removeImage,
    TResult? Function(ConnectorTypeModel? selectedConnector)?
        connectorTypeChangedEvent,
    TResult? Function(String startTime)? startTimeSelected,
    TResult? Function(String endTime)? endTimeSelected,
    TResult? Function(String address)? getAddress,
  }) {
    return endTimeSelected?.call(endTime);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(List<File> images)? imagesSelected,
    TResult Function(int index)? removeImage,
    TResult Function(ConnectorTypeModel? selectedConnector)?
        connectorTypeChangedEvent,
    TResult Function(String startTime)? startTimeSelected,
    TResult Function(String endTime)? endTimeSelected,
    TResult Function(String address)? getAddress,
    required TResult orElse(),
  }) {
    if (endTimeSelected != null) {
      return endTimeSelected(endTime);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_StartedEvent value) started,
    required TResult Function(_ImagesSelectedEvent value) imagesSelected,
    required TResult Function(_RemoveImageEvent value) removeImage,
    required TResult Function(_ConnectorTypeChangedEvent value)
        connectorTypeChangedEvent,
    required TResult Function(_StartTimeSelectedEvent value) startTimeSelected,
    required TResult Function(_EndTimeSelectedEvent value) endTimeSelected,
    required TResult Function(_GetAddressEvent value) getAddress,
  }) {
    return endTimeSelected(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_StartedEvent value)? started,
    TResult? Function(_ImagesSelectedEvent value)? imagesSelected,
    TResult? Function(_RemoveImageEvent value)? removeImage,
    TResult? Function(_ConnectorTypeChangedEvent value)?
        connectorTypeChangedEvent,
    TResult? Function(_StartTimeSelectedEvent value)? startTimeSelected,
    TResult? Function(_EndTimeSelectedEvent value)? endTimeSelected,
    TResult? Function(_GetAddressEvent value)? getAddress,
  }) {
    return endTimeSelected?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_StartedEvent value)? started,
    TResult Function(_ImagesSelectedEvent value)? imagesSelected,
    TResult Function(_RemoveImageEvent value)? removeImage,
    TResult Function(_ConnectorTypeChangedEvent value)?
        connectorTypeChangedEvent,
    TResult Function(_StartTimeSelectedEvent value)? startTimeSelected,
    TResult Function(_EndTimeSelectedEvent value)? endTimeSelected,
    TResult Function(_GetAddressEvent value)? getAddress,
    required TResult orElse(),
  }) {
    if (endTimeSelected != null) {
      return endTimeSelected(this);
    }
    return orElse();
  }
}

abstract class _EndTimeSelectedEvent implements AddStationEvent {
  const factory _EndTimeSelectedEvent(final String endTime) =
      _$EndTimeSelectedEventImpl;

  String get endTime;

  /// Create a copy of AddStationEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$EndTimeSelectedEventImplCopyWith<_$EndTimeSelectedEventImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$GetAddressEventImplCopyWith<$Res> {
  factory _$$GetAddressEventImplCopyWith(_$GetAddressEventImpl value,
          $Res Function(_$GetAddressEventImpl) then) =
      __$$GetAddressEventImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String address});
}

/// @nodoc
class __$$GetAddressEventImplCopyWithImpl<$Res>
    extends _$AddStationEventCopyWithImpl<$Res, _$GetAddressEventImpl>
    implements _$$GetAddressEventImplCopyWith<$Res> {
  __$$GetAddressEventImplCopyWithImpl(
      _$GetAddressEventImpl _value, $Res Function(_$GetAddressEventImpl) _then)
      : super(_value, _then);

  /// Create a copy of AddStationEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? address = null,
  }) {
    return _then(_$GetAddressEventImpl(
      null == address
          ? _value.address
          : address // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$GetAddressEventImpl implements _GetAddressEvent {
  const _$GetAddressEventImpl(this.address);

  @override
  final String address;

  @override
  String toString() {
    return 'AddStationEvent.getAddress(address: $address)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GetAddressEventImpl &&
            (identical(other.address, address) || other.address == address));
  }

  @override
  int get hashCode => Object.hash(runtimeType, address);

  /// Create a copy of AddStationEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$GetAddressEventImplCopyWith<_$GetAddressEventImpl> get copyWith =>
      __$$GetAddressEventImplCopyWithImpl<_$GetAddressEventImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(List<File> images) imagesSelected,
    required TResult Function(int index) removeImage,
    required TResult Function(ConnectorTypeModel? selectedConnector)
        connectorTypeChangedEvent,
    required TResult Function(String startTime) startTimeSelected,
    required TResult Function(String endTime) endTimeSelected,
    required TResult Function(String address) getAddress,
  }) {
    return getAddress(address);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(List<File> images)? imagesSelected,
    TResult? Function(int index)? removeImage,
    TResult? Function(ConnectorTypeModel? selectedConnector)?
        connectorTypeChangedEvent,
    TResult? Function(String startTime)? startTimeSelected,
    TResult? Function(String endTime)? endTimeSelected,
    TResult? Function(String address)? getAddress,
  }) {
    return getAddress?.call(address);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(List<File> images)? imagesSelected,
    TResult Function(int index)? removeImage,
    TResult Function(ConnectorTypeModel? selectedConnector)?
        connectorTypeChangedEvent,
    TResult Function(String startTime)? startTimeSelected,
    TResult Function(String endTime)? endTimeSelected,
    TResult Function(String address)? getAddress,
    required TResult orElse(),
  }) {
    if (getAddress != null) {
      return getAddress(address);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_StartedEvent value) started,
    required TResult Function(_ImagesSelectedEvent value) imagesSelected,
    required TResult Function(_RemoveImageEvent value) removeImage,
    required TResult Function(_ConnectorTypeChangedEvent value)
        connectorTypeChangedEvent,
    required TResult Function(_StartTimeSelectedEvent value) startTimeSelected,
    required TResult Function(_EndTimeSelectedEvent value) endTimeSelected,
    required TResult Function(_GetAddressEvent value) getAddress,
  }) {
    return getAddress(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_StartedEvent value)? started,
    TResult? Function(_ImagesSelectedEvent value)? imagesSelected,
    TResult? Function(_RemoveImageEvent value)? removeImage,
    TResult? Function(_ConnectorTypeChangedEvent value)?
        connectorTypeChangedEvent,
    TResult? Function(_StartTimeSelectedEvent value)? startTimeSelected,
    TResult? Function(_EndTimeSelectedEvent value)? endTimeSelected,
    TResult? Function(_GetAddressEvent value)? getAddress,
  }) {
    return getAddress?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_StartedEvent value)? started,
    TResult Function(_ImagesSelectedEvent value)? imagesSelected,
    TResult Function(_RemoveImageEvent value)? removeImage,
    TResult Function(_ConnectorTypeChangedEvent value)?
        connectorTypeChangedEvent,
    TResult Function(_StartTimeSelectedEvent value)? startTimeSelected,
    TResult Function(_EndTimeSelectedEvent value)? endTimeSelected,
    TResult Function(_GetAddressEvent value)? getAddress,
    required TResult orElse(),
  }) {
    if (getAddress != null) {
      return getAddress(this);
    }
    return orElse();
  }
}

abstract class _GetAddressEvent implements AddStationEvent {
  const factory _GetAddressEvent(final String address) = _$GetAddressEventImpl;

  String get address;

  /// Create a copy of AddStationEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$GetAddressEventImplCopyWith<_$GetAddressEventImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$AddStationState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String message) error,
    required TResult Function(
            List<ConnectorTypeModel> connectors,
            int? initialSelectedConnectorId,
            List<File>? images,
            String? startTime,
            String? endTime,
            String? address)
        loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String message)? error,
    TResult? Function(
            List<ConnectorTypeModel> connectors,
            int? initialSelectedConnectorId,
            List<File>? images,
            String? startTime,
            String? endTime,
            String? address)?
        loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String message)? error,
    TResult Function(
            List<ConnectorTypeModel> connectors,
            int? initialSelectedConnectorId,
            List<File>? images,
            String? startTime,
            String? endTime,
            String? address)?
        loaded,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialState value) initial,
    required TResult Function(_LoadingState value) loading,
    required TResult Function(_ErrorState value) error,
    required TResult Function(_LoadedState value) loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialState value)? initial,
    TResult? Function(_LoadingState value)? loading,
    TResult? Function(_ErrorState value)? error,
    TResult? Function(_LoadedState value)? loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialState value)? initial,
    TResult Function(_LoadingState value)? loading,
    TResult Function(_ErrorState value)? error,
    TResult Function(_LoadedState value)? loaded,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddStationStateCopyWith<$Res> {
  factory $AddStationStateCopyWith(
          AddStationState value, $Res Function(AddStationState) then) =
      _$AddStationStateCopyWithImpl<$Res, AddStationState>;
}

/// @nodoc
class _$AddStationStateCopyWithImpl<$Res, $Val extends AddStationState>
    implements $AddStationStateCopyWith<$Res> {
  _$AddStationStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AddStationState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$InitialStateImplCopyWith<$Res> {
  factory _$$InitialStateImplCopyWith(
          _$InitialStateImpl value, $Res Function(_$InitialStateImpl) then) =
      __$$InitialStateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialStateImplCopyWithImpl<$Res>
    extends _$AddStationStateCopyWithImpl<$Res, _$InitialStateImpl>
    implements _$$InitialStateImplCopyWith<$Res> {
  __$$InitialStateImplCopyWithImpl(
      _$InitialStateImpl _value, $Res Function(_$InitialStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of AddStationState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$InitialStateImpl implements _InitialState {
  const _$InitialStateImpl();

  @override
  String toString() {
    return 'AddStationState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialStateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String message) error,
    required TResult Function(
            List<ConnectorTypeModel> connectors,
            int? initialSelectedConnectorId,
            List<File>? images,
            String? startTime,
            String? endTime,
            String? address)
        loaded,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String message)? error,
    TResult? Function(
            List<ConnectorTypeModel> connectors,
            int? initialSelectedConnectorId,
            List<File>? images,
            String? startTime,
            String? endTime,
            String? address)?
        loaded,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String message)? error,
    TResult Function(
            List<ConnectorTypeModel> connectors,
            int? initialSelectedConnectorId,
            List<File>? images,
            String? startTime,
            String? endTime,
            String? address)?
        loaded,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialState value) initial,
    required TResult Function(_LoadingState value) loading,
    required TResult Function(_ErrorState value) error,
    required TResult Function(_LoadedState value) loaded,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialState value)? initial,
    TResult? Function(_LoadingState value)? loading,
    TResult? Function(_ErrorState value)? error,
    TResult? Function(_LoadedState value)? loaded,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialState value)? initial,
    TResult Function(_LoadingState value)? loading,
    TResult Function(_ErrorState value)? error,
    TResult Function(_LoadedState value)? loaded,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _InitialState implements AddStationState {
  const factory _InitialState() = _$InitialStateImpl;
}

/// @nodoc
abstract class _$$LoadingStateImplCopyWith<$Res> {
  factory _$$LoadingStateImplCopyWith(
          _$LoadingStateImpl value, $Res Function(_$LoadingStateImpl) then) =
      __$$LoadingStateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadingStateImplCopyWithImpl<$Res>
    extends _$AddStationStateCopyWithImpl<$Res, _$LoadingStateImpl>
    implements _$$LoadingStateImplCopyWith<$Res> {
  __$$LoadingStateImplCopyWithImpl(
      _$LoadingStateImpl _value, $Res Function(_$LoadingStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of AddStationState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$LoadingStateImpl implements _LoadingState {
  const _$LoadingStateImpl();

  @override
  String toString() {
    return 'AddStationState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadingStateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String message) error,
    required TResult Function(
            List<ConnectorTypeModel> connectors,
            int? initialSelectedConnectorId,
            List<File>? images,
            String? startTime,
            String? endTime,
            String? address)
        loaded,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String message)? error,
    TResult? Function(
            List<ConnectorTypeModel> connectors,
            int? initialSelectedConnectorId,
            List<File>? images,
            String? startTime,
            String? endTime,
            String? address)?
        loaded,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String message)? error,
    TResult Function(
            List<ConnectorTypeModel> connectors,
            int? initialSelectedConnectorId,
            List<File>? images,
            String? startTime,
            String? endTime,
            String? address)?
        loaded,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialState value) initial,
    required TResult Function(_LoadingState value) loading,
    required TResult Function(_ErrorState value) error,
    required TResult Function(_LoadedState value) loaded,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialState value)? initial,
    TResult? Function(_LoadingState value)? loading,
    TResult? Function(_ErrorState value)? error,
    TResult? Function(_LoadedState value)? loaded,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialState value)? initial,
    TResult Function(_LoadingState value)? loading,
    TResult Function(_ErrorState value)? error,
    TResult Function(_LoadedState value)? loaded,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _LoadingState implements AddStationState {
  const factory _LoadingState() = _$LoadingStateImpl;
}

/// @nodoc
abstract class _$$ErrorStateImplCopyWith<$Res> {
  factory _$$ErrorStateImplCopyWith(
          _$ErrorStateImpl value, $Res Function(_$ErrorStateImpl) then) =
      __$$ErrorStateImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$ErrorStateImplCopyWithImpl<$Res>
    extends _$AddStationStateCopyWithImpl<$Res, _$ErrorStateImpl>
    implements _$$ErrorStateImplCopyWith<$Res> {
  __$$ErrorStateImplCopyWithImpl(
      _$ErrorStateImpl _value, $Res Function(_$ErrorStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of AddStationState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$ErrorStateImpl(
      null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ErrorStateImpl implements _ErrorState {
  const _$ErrorStateImpl(this.message);

  @override
  final String message;

  @override
  String toString() {
    return 'AddStationState.error(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ErrorStateImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  /// Create a copy of AddStationState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ErrorStateImplCopyWith<_$ErrorStateImpl> get copyWith =>
      __$$ErrorStateImplCopyWithImpl<_$ErrorStateImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String message) error,
    required TResult Function(
            List<ConnectorTypeModel> connectors,
            int? initialSelectedConnectorId,
            List<File>? images,
            String? startTime,
            String? endTime,
            String? address)
        loaded,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String message)? error,
    TResult? Function(
            List<ConnectorTypeModel> connectors,
            int? initialSelectedConnectorId,
            List<File>? images,
            String? startTime,
            String? endTime,
            String? address)?
        loaded,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String message)? error,
    TResult Function(
            List<ConnectorTypeModel> connectors,
            int? initialSelectedConnectorId,
            List<File>? images,
            String? startTime,
            String? endTime,
            String? address)?
        loaded,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialState value) initial,
    required TResult Function(_LoadingState value) loading,
    required TResult Function(_ErrorState value) error,
    required TResult Function(_LoadedState value) loaded,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialState value)? initial,
    TResult? Function(_LoadingState value)? loading,
    TResult? Function(_ErrorState value)? error,
    TResult? Function(_LoadedState value)? loaded,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialState value)? initial,
    TResult Function(_LoadingState value)? loading,
    TResult Function(_ErrorState value)? error,
    TResult Function(_LoadedState value)? loaded,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _ErrorState implements AddStationState {
  const factory _ErrorState(final String message) = _$ErrorStateImpl;

  String get message;

  /// Create a copy of AddStationState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ErrorStateImplCopyWith<_$ErrorStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LoadedStateImplCopyWith<$Res> {
  factory _$$LoadedStateImplCopyWith(
          _$LoadedStateImpl value, $Res Function(_$LoadedStateImpl) then) =
      __$$LoadedStateImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {List<ConnectorTypeModel> connectors,
      int? initialSelectedConnectorId,
      List<File>? images,
      String? startTime,
      String? endTime,
      String? address});
}

/// @nodoc
class __$$LoadedStateImplCopyWithImpl<$Res>
    extends _$AddStationStateCopyWithImpl<$Res, _$LoadedStateImpl>
    implements _$$LoadedStateImplCopyWith<$Res> {
  __$$LoadedStateImplCopyWithImpl(
      _$LoadedStateImpl _value, $Res Function(_$LoadedStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of AddStationState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? connectors = null,
    Object? initialSelectedConnectorId = freezed,
    Object? images = freezed,
    Object? startTime = freezed,
    Object? endTime = freezed,
    Object? address = freezed,
  }) {
    return _then(_$LoadedStateImpl(
      null == connectors
          ? _value._connectors
          : connectors // ignore: cast_nullable_to_non_nullable
              as List<ConnectorTypeModel>,
      initialSelectedConnectorId: freezed == initialSelectedConnectorId
          ? _value.initialSelectedConnectorId
          : initialSelectedConnectorId // ignore: cast_nullable_to_non_nullable
              as int?,
      images: freezed == images
          ? _value._images
          : images // ignore: cast_nullable_to_non_nullable
              as List<File>?,
      startTime: freezed == startTime
          ? _value.startTime
          : startTime // ignore: cast_nullable_to_non_nullable
              as String?,
      endTime: freezed == endTime
          ? _value.endTime
          : endTime // ignore: cast_nullable_to_non_nullable
              as String?,
      address: freezed == address
          ? _value.address
          : address // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$LoadedStateImpl implements _LoadedState {
  const _$LoadedStateImpl(final List<ConnectorTypeModel> connectors,
      {this.initialSelectedConnectorId,
      final List<File>? images,
      this.startTime,
      this.endTime,
      this.address})
      : _connectors = connectors,
        _images = images;

  final List<ConnectorTypeModel> _connectors;
  @override
  List<ConnectorTypeModel> get connectors {
    if (_connectors is EqualUnmodifiableListView) return _connectors;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_connectors);
  }

  @override
  final int? initialSelectedConnectorId;
  final List<File>? _images;
  @override
  List<File>? get images {
    final value = _images;
    if (value == null) return null;
    if (_images is EqualUnmodifiableListView) return _images;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final String? startTime;
  @override
  final String? endTime;
  @override
  final String? address;

  @override
  String toString() {
    return 'AddStationState.loaded(connectors: $connectors, initialSelectedConnectorId: $initialSelectedConnectorId, images: $images, startTime: $startTime, endTime: $endTime, address: $address)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadedStateImpl &&
            const DeepCollectionEquality()
                .equals(other._connectors, _connectors) &&
            (identical(other.initialSelectedConnectorId,
                    initialSelectedConnectorId) ||
                other.initialSelectedConnectorId ==
                    initialSelectedConnectorId) &&
            const DeepCollectionEquality().equals(other._images, _images) &&
            (identical(other.startTime, startTime) ||
                other.startTime == startTime) &&
            (identical(other.endTime, endTime) || other.endTime == endTime) &&
            (identical(other.address, address) || other.address == address));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_connectors),
      initialSelectedConnectorId,
      const DeepCollectionEquality().hash(_images),
      startTime,
      endTime,
      address);

  /// Create a copy of AddStationState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$LoadedStateImplCopyWith<_$LoadedStateImpl> get copyWith =>
      __$$LoadedStateImplCopyWithImpl<_$LoadedStateImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(String message) error,
    required TResult Function(
            List<ConnectorTypeModel> connectors,
            int? initialSelectedConnectorId,
            List<File>? images,
            String? startTime,
            String? endTime,
            String? address)
        loaded,
  }) {
    return loaded(connectors, initialSelectedConnectorId, images, startTime,
        endTime, address);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(String message)? error,
    TResult? Function(
            List<ConnectorTypeModel> connectors,
            int? initialSelectedConnectorId,
            List<File>? images,
            String? startTime,
            String? endTime,
            String? address)?
        loaded,
  }) {
    return loaded?.call(connectors, initialSelectedConnectorId, images,
        startTime, endTime, address);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(String message)? error,
    TResult Function(
            List<ConnectorTypeModel> connectors,
            int? initialSelectedConnectorId,
            List<File>? images,
            String? startTime,
            String? endTime,
            String? address)?
        loaded,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(connectors, initialSelectedConnectorId, images, startTime,
          endTime, address);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_InitialState value) initial,
    required TResult Function(_LoadingState value) loading,
    required TResult Function(_ErrorState value) error,
    required TResult Function(_LoadedState value) loaded,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_InitialState value)? initial,
    TResult? Function(_LoadingState value)? loading,
    TResult? Function(_ErrorState value)? error,
    TResult? Function(_LoadedState value)? loaded,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_InitialState value)? initial,
    TResult Function(_LoadingState value)? loading,
    TResult Function(_ErrorState value)? error,
    TResult Function(_LoadedState value)? loaded,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class _LoadedState implements AddStationState {
  const factory _LoadedState(final List<ConnectorTypeModel> connectors,
      {final int? initialSelectedConnectorId,
      final List<File>? images,
      final String? startTime,
      final String? endTime,
      final String? address}) = _$LoadedStateImpl;

  List<ConnectorTypeModel> get connectors;
  int? get initialSelectedConnectorId;
  List<File>? get images;
  String? get startTime;
  String? get endTime;
  String? get address;

  /// Create a copy of AddStationState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$LoadedStateImplCopyWith<_$LoadedStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
